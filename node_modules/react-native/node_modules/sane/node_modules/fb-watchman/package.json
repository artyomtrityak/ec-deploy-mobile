{
  "name": "fb-watchman",
  "version": "1.1.0",
  "description": "Bindings for the Watchman file watching service",
  "main": "index.js",
  "scripts": {
    "test": "node test/bser.js"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:facebook/watchman.git"
  },
  "dependencies": {
    "node-int64": "0.4.0"
  },
  "keywords": [
    "facebook",
    "watchman",
    "file",
    "watch",
    "watcher",
    "watching",
    "fs.watch",
    "fswatcher",
    "fs",
    "glob",
    "utility"
  ],
  "author": {
    "name": "Wez Furlong",
    "email": "wez@fb.com",
    "url": "http://wezfurlong.org"
  },
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/facebook/watchman/issues"
  },
  "homepage": "https://facebook.github.io/watchman/",
  "files": [
    "index.js",
    "bser.js"
  ],
  "readme": "# fb-watchman\n\n`fb-watchman` is a filesystem watcher that uses the\n[Watchman](https://facebook.github.io/watchman/) file watching service from\nFacebook.\n\nWatchman provides file change notification services using very\nefficient recursive watches and also allows more advanced change matching and\nfilesystem tree querying operations using\n[a powerful expression syntax](https://facebook.github.io/watchman/docs/file-query.html#expressions).\n\n## Install\n\nYou should [install Watchman](https://facebook.github.io/watchman/docs/install.html) to make the most of this module.\n\nThen simply:\n\n```\n$ npm install fb-watchman\n```\n\n## Key Concepts\n\n- Watchman recursively watches directories.\n- Each watched directory is called a `root`.\n- You must initiate a `watch` on a `root` using the `watch-project` command prior to subscribing to changes\n- Rather than separately watching many sibling directories, `watch-project` consolidates and re-uses existing watches relative to a project root (the location of your `.watchmanconfig` or source control repository root)\n- change notifications are relative to the project root\n\n## Usage\n\n```\nvar watchman = require('fb-watchman');\nvar client = new watchman.Client();\n\nclient.on('end', function() {\n  // Called when the connection to watchman is terminated\n  console.log('client ended');\n});\n\nclient.on('error', function(error) {\n  console.error('Error while talking to watchman: ', error);\n});\n\nclient.command(['version'], function(error, resp) {\n  if (error) {\n    console.error('Error getting version:', error);\n    return;\n  }\n  console.log('Talking to watchman version', resp.version);\n});\n\n// Example of the error case\nclient.command(['invalid-command-never-will-work'], function(error, resp) {\n  if (error) {\n    console.error('failed to subscribe: ', error);\n    return;\n  }\n});\n\n// Initiate a watch.  You can repeatedly ask to watch the same dir without\n// error; Watchman will re-use an existing watch.\nclient.command(['watch-project', process.cwd()], function(error, resp) {\n  if (error) {\n    console.error('Error initiating watch:', error);\n    return;\n  }\n\n  // It is considered to be best practice to show any 'warning' or 'error'\n  // information to the user, as it may suggest steps for remediation\n  if ('warning' in resp) {\n    console.log('warning: ', resp.warning);\n  }\n\n  // The default subscribe behavior is to deliver a list of all current files\n  // when you first subscribe, so you don't need to walk the tree for yourself\n  // on startup.  If you don't want this behavior, you should issue a `clock`\n  // command and use it to give a logical time constraint on the subscription.\n  // See further below for an example of this.\n\n  // watch-project may re-use an existing watch at a higher level in the\n  // filesystem.  It will tell us the relative path to the directory that\n  // we expressed interest in, so we need to adjust for it in our results\n  var path_prefix = '';\n  var root = resp['watch'];\n  if ('relative_path' in resp) {\n    path_prefix = resp['relative_path'];\n    console.log('(re)using project watch at ', root, ', our dir is relative: ',\n        path_prefix);\n  }\n\n  function get_relative_name(proj_rel) {\n    if (path_prefix.length == 0) {\n      return proj_rel;\n    }\n    if (proj_rel.substr(0, path_prefix.length) == path_prefix) {\n      return proj_rel.substr(path_prefix.length + 1);\n    }\n    return null;\n  }\n\n  // Subscribe to notifications about .js files\n  // https://facebook.github.io/watchman/docs/cmd/subscribe.html\n  client.command(['subscribe', root, 'mysubscription', {\n      // Match any .js file under process.cwd()\n      // https://facebook.github.io/watchman/docs/file-query.html#expressions\n      // Has more on the supported expression syntax\n      expression: [\"allof\",\n          [\"match\", \"*.js\"],\n          // focus on the relative path from the project to the path\n          // of interest\n          ['dirname', path_prefix]\n      ],\n      // Which fields we're interested in\n      fields: [\"name\", \"size\", \"exists\", \"type\"]\n    }],\n    function(error, resp) {\n      if (error) {\n        // Probably an error in the subscription criteria\n        console.error('failed to subscribe: ', error);\n        return;\n      }\n      console.log('subscription ' + resp.subscribe + ' established');\n    }\n  );\n\n  // Subscription results are emitted via the subscription event.\n  // Note that this emits for all subscriptions.  If you have\n  // subscriptions with different `fields` you will need to check\n  // the subscription name and handle the differing data accordingly\n  client.on('subscription', function(resp) {\n    // Each entry in `resp.files` will have the fields you requested\n    // in your subscription.  The default is:\n    //  { name: 'example.js',\n    //    size: 1680,\n    //    new: true,\n    //    exists: true,\n    //    mode: 33188 }\n    //\n    // Names are relative to resp.root; join them together to\n    // obtain a fully qualified path.\n    //\n    // `resp`  looks like this in practice:\n    //\n    // { root: '/private/tmp/foo',\n    //   subscription: 'mysubscription',\n    //   files: [ { name: 'node_modules/fb-watchman/index.js',\n    //       size: 4768,\n    //       exists: true,\n    //       mode: 33188 } ] }\n    console.log(resp.root, resp.subscription);\n    for (var i in resp.files) {\n      var f = resp.files[i];\n      // Fixup name for watch-project offset\n      if (resp.subscription == 'mysubscription') {\n        // we requested a set of fields in this subscription\n        f.name = get_relative_name(f.name);\n      } else {\n        // the other subscription we set up returns only the name\n        f = get_relative_name(f);\n      }\n      console.log(f);\n    }\n  });\n\n  // Here's an example of just subscribing for notifications after the\n  // current point in time\n  client.command(['clock', root], function(error, resp) {\n    if (error) {\n      console.error('Failed to query clock:', error);\n      return;\n    }\n\n    client.command(['subscribe', root, 'sincesub', {\n        expression: ['allof',\n          [\"match\", \"*.js\"],\n          // focus on the relative path from the project to the path\n          // of interest\n          ['dirname', path_prefix]\n        ],\n        // Note: since we only request a single field, the `sincesub` subscription\n        // response will just set files to an array of filenames, not an array of\n        // objects with name properties\n        // { root: '/private/tmp/foo',\n        //   subscription: 'sincesub',\n        //   files: [ 'node_modules/fb-watchman/index.js' ] }\n        fields: [\"name\"],\n        since: resp.clock // time constraint\n      }],\n      function(error, resp) {\n        if (error) {\n          console.error('failed to subscribe: ', error);\n          return;\n        }\n        console.log('subscription ' + resp.subscribe + ' established');\n      }\n    );\n  });\n});\n```\n\n## Methods\n\n### client.command(args [, done])\n\nSends a command to the watchman service.  `args` is an array that specifies\nthe command name and any optional arguments.  The command is queued and\ndispatched asynchronously.  You may queue multiple commands to the service;\nthey will be dispatched in FIFO order once the client connection is established.\n\nThe `done` parameter is a callback that will be passed (error, result) when the\ncommand completes.  You may omit it if you are not interested in the result of\nthe command.\n\n```\nclient.command(['watch-project', process.cwd()], function(error, resp) {\n  if (error) {\n    console.log('watch failed: ', error);\n    return;\n  }\n  if ('warning' in resp) {\n    console.log('warning: ', resp.warning);\n  }\n  if ('relative_path' in resp) {\n    // We will need to remember and adjust for relative_path\n    console.log('watching project ', resp.watch, ' relative path to cwd is ',\n      resp.relative_path);\n  } else {\n    console.log('watching ', resp.watch);\n  }\n});\n```\n\nIf a field named `warning` is present in `resp`, the watchman service is trying\nto communicate an issue that the user should see and address.  For example, if\nthe system watch resources need adjustment, watchman will provide information\nabout this and how to remediate the issue.  It is suggested that tools that\nbuild on top of this library bubble the warning message up to the user.\n\n### client.end()\n\nTerminates the connection to the watchman service.  Does not wait\nfor any queued commands to send.\n\n## Events\n\nThe following events are emitted by the watchman client object:\n\n### Event: 'connect'\n\nEmitted when the client successfully connects to the watchman service\n\n### Event: 'error'\n\nEmitted when the socket to the watchman service encounters an error.\n\nIt may also be emitted prior to establishing a connection if we are unable\nto successfully execute the watchman CLI binary to determine how to talk\nto the server process.\n\nIt is passed a variable that encapsulates the error.\n\n### Event: 'end'\n\nEmitted when the socket to the watchman service is closed\n\n### Event: 'log'\n\nEmitted in response to a unilateral `log` PDU from the watchman service.\nTo enable these, you need to send a `log-level` command to the service:\n\n```\n// This is very verbose, you probably don't want to do this\nclient.command(['log-level', 'debug']);\nclient.on('log', function(info) {\n  console.log(info);\n});\n```\n\n### Event: 'subscription'\n\nEmitted in response to a unilateral `subscription` PDU from the watchman\nservice.  To enable these, you need to send a `subscribe` command to the service:\n\n```\n  // Subscribe to notifications about .js files\n  client.command(['subscribe', process.cwd(), 'mysubscription', {\n      expression: [\"match\", \"*.js\"]\n    }],\n    function(error, resp) {\n      if (error) {\n        // Probably an error in the subscription criteria\n        console.log('failed to subscribe: ', error);\n        return;\n      }\n      console.log('subscription ' + resp.subscribe + ' established');\n    }\n  );\n\n  // Subscription results are emitted via the subscription event.\n  // Note that watchman will deliver a list of all current files\n  // when you first subscribe, so you don't need to walk the tree\n  // for yourself on startup\n  client.on('subscription', function(resp) {\n    console.log(resp.root, resp.subscription, resp.files);\n  });\n```\n\nTo cancel a subscription, use the `unsubscribe` command and pass in the name of\nthe subscription you want to cancel:\n\n```\n  client.command(['unsubscribe', process.cwd(), 'mysubscription']);\n```\n\nNote that subscriptions names are scoped to your connection to the watchman\nservice; multiple different clients can use the same subscription name without\nfear of colliding.\n\n\n",
  "readmeFilename": "README.md",
  "_id": "fb-watchman@1.1.0",
  "_shasum": "d589252da78b349035b5cc25acf4f650298ba582",
  "_from": "fb-watchman@^1.1.0",
  "_resolved": "https://registry.npmjs.org/fb-watchman/-/fb-watchman-1.1.0.tgz"
}
